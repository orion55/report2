{"version":3,"sources":["../../src/models/answersModel.js"],"names":["_","require","dbOrcl","answersModel","getReport","arrDate","Promise","resolve","reject","sql","process","env","NODE_ENV","doConnect","then","doExecuteArr","connection","arrRows","metaData","result","map","el","name","processResultSet","resultSet","getRow","row","doCloseResultSet","rows","push","catch","doClose","status","msg","detail_msg","err","message","getReport2","mymaxnumrows","promiseTotal","doExecute","promiseItem","offset","maxnumrows","pop","data","promiseTotalResult","countPromise","Math","ceil","arrPromise","myoffset","i","all","flattenDepth","values"],"mappings":"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","file":"answersModel.js","sourcesContent":["import Db from './db';\r\nimport {jsUcfirst, nonSpecialSymbol} from '../util';\r\nlet _ = require('lodash');\r\n\r\nlet dbOrcl = new Db();\r\n\r\nexport default class answersModel {\r\n    getReport = (arrDate) => {\r\n        return new Promise((resolve, reject) => {\r\n            let sql = '';\r\n\r\n            if (process.env.NODE_ENV === 'home') {\r\n                sql = `select t.operdate,\r\n                     t.closedate,\r\n                     t.closeday,\r\n                     t.closetime,\r\n                     t.usercodeopen,\r\n                     t.usercodeclose,\r\n                     t.unloadseqdel,\r\n                     t.unloadseqback,\r\n                     t.btrv_address,\r\n                     t.rowver\r\n                     from operdays t\r\n                     where t.operdate >= to_date(:dateFrom, 'mm.dd.yyyy')\r\n                     and t.operdate <= to_date(:dateTo, 'mm.dd.yyyy')\r\n                     order by t.operdate asc`;\r\n            } else {\r\n                sql = 'select t.docdate AS \"Дата ED274\", ' +\r\n                    't.opernum AS \"Код ED273\", ' +\r\n                    'p.docdate AS \"Дата документа\", ' +\r\n                    'p.docnum  AS \"Номер документа\", ' +\r\n                    'p.paysum  AS \"Сумма документа\", ' +\r\n                    'i.ed244_answercode, ' +\r\n                    'i.ed244_purpose ' +\r\n                    'FROM ESIDMESSAGE t, esid273doc a, payorder p, inesidmessage i ' +\r\n                    \"where t.doctype = 273 \" +\r\n                    \"and t.opernum = a.esidopernum \" +\r\n                    \"AND p.opernum = a.payopernum \" +\r\n                    \"AND i.edtype = 'ED274' \" +\r\n                    \"and i.eddate >= to_date(:dateFrom, 'mm.dd.yyyy') \" +\r\n                    \"and i.eddate <= to_date(:dateTo, 'mm.dd.yyyy') \" +\r\n                    \"AND a.edno = MOD(i.ed243_edno / 1000, 1) * 1000\" +\r\n                    \"AND i.ed243_eddate = a.eddate\";\r\n            }\r\n            dbOrcl.doConnect()\r\n                .then(connection => {\r\n                    return dbOrcl.doExecuteArr(connection, sql, arrDate)\r\n                        .then(result => {\r\n                            let arrRows = [];\r\n                            const metaData = result.metaData.map(el => jsUcfirst(el.name));\r\n\r\n                            function processResultSet() {\r\n                                result.resultSet.getRow()\r\n                                    .then(row => {\r\n                                        if (!row) {\r\n                                            dbOrcl.doCloseResultSet(result.resultSet);\r\n                                            // console.log(arrRows.length);\r\n                                            return resolve({rows: arrRows, metaData: metaData});\r\n                                        }\r\n                                        arrRows.push(row.map(el => nonSpecialSymbol(el)));\r\n                                        processResultSet();\r\n                                    })\r\n                            }\r\n\r\n                            processResultSet();\r\n                        })\r\n                        .catch(err => {\r\n                            dbOrcl.doClose(connection);\r\n                            reject({status: 500, msg: \"Error getting data\", detail_msg: err.message});\r\n                        })\r\n                })\r\n                .catch(err => {\r\n                    reject({status: 500, msg: \"Error connecting to DB\", detail_msg: err.message});\r\n                });\r\n        })\r\n    };\r\n\r\n    getReport2 = (arrDate) => {\r\n        const mymaxnumrows = 100;\r\n        let metaData = [];\r\n\r\n        let promiseTotal = new Promise((resolve, reject) => {\r\n            let sql = 'select COUNT(t.docdate) \"Total\"' +\r\n                'FROM ESIDMESSAGE t, esid273doc a, payorder p, inesidmessage i ' +\r\n                \"where t.doctype = 273 \" +\r\n                \"and t.opernum = a.esidopernum \" +\r\n                \"AND p.opernum = a.payopernum \" +\r\n                \"AND i.edtype = 'ED274' \" +\r\n                \"and i.eddate >= to_date(:dateFrom, 'mm.dd.yyyy') \" +\r\n                \"and i.eddate <= to_date(:dateTo, 'mm.dd.yyyy') \" +\r\n                \"AND a.edno = MOD(i.ed243_edno / 1000, 1) * 1000\" +\r\n                \"AND i.ed243_eddate = a.eddate\";\r\n            dbOrcl.doConnect()\r\n                .then(connection => {\r\n                    return dbOrcl.doExecute(connection, sql, arrDate)\r\n                        .then(result => {\r\n                            resolve(result.rows[0][0]);\r\n                        })\r\n                        .catch(err => {\r\n                            dbOrcl.doClose(connection);\r\n                            reject({status: 500, msg: \"Error getting data\", detail_msg: err.message});\r\n                        })\r\n                })\r\n                .catch(err => {\r\n                    reject({status: 500, msg: \"Error connecting to DB\", detail_msg: err.message});\r\n                });\r\n        });\r\n\r\n        function promiseItem(offset) {\r\n            return new Promise((resolve, reject) => {\r\n                let sql = 'select t.docdate AS \"Дата ED274\", ' +\r\n                    't.opernum AS \"Код ED273\", ' +\r\n                    'p.docdate AS \"Дата документа\", ' +\r\n                    'p.docnum  AS \"Номер документа\", ' +\r\n                    'p.paysum  AS \"Сумма документа\", ' +\r\n                    'i.ed244_answercode, ' +\r\n                    'i.ed244_purpose ' +\r\n                    'FROM ESIDMESSAGE t, esid273doc a, payorder p, inesidmessage i ' +\r\n                    \"where t.doctype = 273 \" +\r\n                    \"and t.opernum = a.esidopernum \" +\r\n                    \"AND p.opernum = a.payopernum \" +\r\n                    \"AND i.edtype = 'ED274' \" +\r\n                    \"and i.eddate >= to_date(:dateFrom, 'mm.dd.yyyy') \" +\r\n                    \"and i.eddate <= to_date(:dateTo, 'mm.dd.yyyy') \" +\r\n                    \"AND a.edno = MOD(i.ed243_edno / 1000, 1) * 1000\" +\r\n                    \"AND i.ed243_eddate = a.eddate\";\r\n\r\n                sql = \"SELECT * FROM (SELECT A.*, ROWNUM AS MY_RNUM FROM\"\r\n                    + \"(\" + sql + \") A \"\r\n                    + \"WHERE ROWNUM <= :maxnumrows + :offset) WHERE MY_RNUM > :offset\";\r\n\r\n                dbOrcl.doConnect()\r\n                    .then(connection => {\r\n                        return dbOrcl.doExecuteArr(connection, sql, {\r\n                            ...arrDate,\r\n                            offset: offset,\r\n                            maxnumrows: mymaxnumrows\r\n                        })\r\n                            .then(result => {\r\n                                metaData = result.metaData.map(el => jsUcfirst(el.name)).map(el => nonSpecialSymbol(el));\r\n                                metaData.pop();\r\n                                let arrRows = [];\r\n\r\n                                function processResultSet() {\r\n                                    result.resultSet.getRow()\r\n                                        .then(row => {\r\n                                            if (!row) {\r\n                                                dbOrcl.doCloseResultSet(result.resultSet);\r\n                                                return resolve(arrRows);\r\n                                            }\r\n\r\n                                            let data = row.map(el => nonSpecialSymbol(el));\r\n                                            data.pop();\r\n                                            arrRows.push(data);\r\n\r\n                                            processResultSet();\r\n                                        })\r\n                                }\r\n\r\n                                processResultSet();\r\n                            })\r\n                            .catch(err => {\r\n                                dbOrcl.doClose(connection);\r\n                                reject({status: 500, msg: \"Error getting data\", detail_msg: err.message});\r\n                            })\r\n                    })\r\n                    .catch(err => {\r\n                        reject({status: 500, msg: \"Error connecting to DB\", detail_msg: err.message});\r\n                    });\r\n            });\r\n        }\r\n\r\n        let promiseTotalResult = new Promise(function (resolve, reject) {\r\n            promiseTotal\r\n                .then(result => {\r\n                    const countPromise = Math.ceil(result / mymaxnumrows);\r\n                    let arrPromise = [];\r\n                    let myoffset = 0;\r\n\r\n                    for (let i = 1; i <= countPromise; i++) {\r\n                        arrPromise.push(promiseItem(myoffset));\r\n                        myoffset += mymaxnumrows;\r\n                    }\r\n\r\n                    resolve(arrPromise);\r\n                })\r\n                .catch(err => {\r\n                    reject(err);\r\n                });\r\n        });\r\n\r\n        return new Promise(function (resolve, reject) {\r\n            promiseTotalResult\r\n                .then(arrPromise => {\r\n                    Promise.all(arrPromise)\r\n                        .then(values => {\r\n                            resolve({rows: _.flattenDepth(values, 1), metaData: metaData});\r\n                        })\r\n                        .catch(err => {\r\n                            reject(err);\r\n                        });\r\n                });\r\n        });\r\n    };\r\n}"]}